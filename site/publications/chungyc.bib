@proceedings{monarch:vldb2020,
  title     = {{M}onarch: {G}oogle's Planet-Scale In-Memory Time Series Database},
  author    = {Colin Adams and Luis Alonso and Ben Atkin and John P. Banning and Sumeer Bhola and Rick Buskens and Ming Chen and Xi Chen and Yoo Chung and Qin Jia and Nick Sakharov and George T. Talbot and Adam Jacob Tart and Nick Taylor},
  year      = {2020},
  month     = {aug},
  booktitle = {Proceedings of the VLDB Endowment},
  volume    = {13},
  issue     = {12},
  pages     = {3181--3194},
  doi       = {10.14778/3181-3194}
}

@article{chung:sigcomm2012,
  author     = {Chung, Yoo},
  title      = {Distributed Denial of Service is a Scalability Problem},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {42},
  number     = {1},
  issn       = {0146-4833},
  url        = {https://doi.org/10.1145/2096149.2096160},
  doi        = {10.1145/2096149.2096160},
  abstract   = {Distributed denial of service attacks are often considered just a security problem. While this may be the way to view the problem with the Internet of today, perhaps new network architectures attempting to address the issue should view it as a scalability problem. In addition, they may need to approach the problem based on a rigorous foundation.},
  journal    = {ACM SIGCOMM Computer Communication Review},
  month      = {jan},
  pages      = {69--71},
  numpages   = {3},
  keywords   = {security, distributed denial of service, scalability}
}

@inproceedings{chung:nsw2011,
  author    = {Yoo Chung},
  booktitle = {Proceedings of the 2011 IEEE 1st International Network Science Workshop},
  title     = {Modeling network technology deployment rates with different network models},
  year      = {2011},
  month     = {jun},
  pages     = {82--89},
  location  = {West Point, New York},
  publisher = {IEEE},
  doi       = {10.1109/NSW.2011.6004662}
}

@techreport{kang:nims2011,
  author      = {Jung Im Kang and Daeyeoul Kim and Okyu Kwon and Jungyeun Lee and Sangsu Jung and Yoo Chung and Boram Jin and Jee-Wan Huh},
  institution = {National Institute for Mathematical Sciences},
  title       = {Applications of Mathematical Science to Computer Networks},
  type        = {Technical Report},
  number      = {NIMS-FI-2011-02},
  year        = {2011},
  month       = {may},
  note        = {In Korean.}
}

@techreport{jin:nims2011,
  author      = {Boram Jin and Dohyung Kim and Yoo Chung},
  institution = {National Institute for Mathematical Sciences},
  title       = {Survey of Problems with Today's {I}nternet},
  type        = {Technical Report},
  number      = {NIMS-FI-2011-01},
  year        = {2011},
  month       = {feb},
  note        = {In Korean.},
  url         = {https://chungyc.org/files/publications/NIMS-FI-2011-01.pdf}
}

@inproceedings{chung:iasted2011,
  author    = {Yoo Chung},
  booktitle = {Proceedings of the Tenth IASTED International Conference on Software Engineering},
  title     = {Precisely Analyzing Loss in Interface Adapter Chains},
  pages     = {212--217},
  year      = {2011},
  month     = {feb},
  publisher = {International Association of Science and Technology for Development},
  doi       = {10.2316/P.2011.720-059}
}

@inproceedings{chung:ispa2010,
  author    = {Yoo Chung},
  booktitle = {International Symposium on Parallel and Distributed Processing with Applications},
  title     = {Efficient Batch Update of Unique Identifiers in a Distributed Hash Table for Resources in a Mobile Host},
  year      = {2010},
  pages     = {625--630},
  abstract  = {Resources in a cloud can be identified using identifiers based on random numbers. When using a distributed hash table to resolve such identifiers to network locations, the straightforward approach is to store the network location directly in the hash table entry associated with an identifier. When a mobile host contains a large number of resources, this requires that all of the associated hash table entries must be updated when its network address changes. We propose an alternative approach where we store a host identifier in the entry associated with a resource identifier and the actual network address of the host in a separate host entry. This can drastically reduce the time required for updating the distributed hash table when a mobile host changes its network address. We also investigate under which circumstances our approach should or should not be used. We evaluate and confirm the usefulness of our approach with experiments run on top of OpenDHT.},
  doi       = {10.1109/ISPA.2010.73},
  url       = {https://doi.ieeecomputersociety.org/10.1109/ISPA.2010.73},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {sep}
}

@inproceedings{chung:icsess2010,
  author    = {Chung, Yoo and Lee, Dongman},
  booktitle = {2010 IEEE International Conference on Software Engineering and Service Sciences},
  title     = {Web of lossy adapters for interface interoperability: An algorithm and {NP}-completeness of minimization},
  year      = {2010},
  pages     = {95--98},
  abstract  = {By using different interface adapters for different methods, it is possible to construct a maximally covering web of interface adapters which incurs minimum loss during interface adaptation. We introduce a polynomial-time algorithm that can achieve this. However, we also show that minimizing the number of adapters included in a maximally covering web of interface adapters is an NP-complete problem.},
  doi       = {10.1109/ICSESS.2010.5552291},
  issn      = {2327-0594},
  month     = {jul}
}


@article{chung:iet2010,
  author    = {Yoo Chung and Dongman Lee},
  keywords  = {lossy interface adapters;multiple network services;NP-complete problem;matrix-based mathematical basis;ubiquitous computing environments;3SAT;},
  issn      = {1751-8806},
  abstract  = {Despite providing similar functionality, multiple network services may require the use of different interfaces to access the functionality, and this problem will only become worse with the widespread deployment of ubiquitous computing environments. One way around this problem is to use interface adapters that adapt one interface into another. Chaining these adapters allows flexible interface adaptation with fewer adapters, but the loss incurred because of imperfect interface adaptation must be considered. This study outlines a matrix-based mathematical basis for analysing the chaining of lossy interface adapters. The authors also show that the problem of finding an optimal interface adapter chain is NP-complete with a reduction from 3SAT.},
  title     = {Mathematical basis for the chaining of lossy interface adapters},
  journal   = {IET Software},
  volume    = {4},
  number    = {1},
  year      = {2010},
  month     = {February},
  pages     = {43--54},
  publisher = {Institution of Engineering and Technology},
  doi       = {10.1049/iet-sen.2009.0019}
}

@phdthesis{chung:thesis2010,
  author = {Yoo Chul Chung},
  school = {KAIST},
  title  = {Formal Analysis Framework for Lossy Interface Adapter Chaining},
  year   = {2010},
  month  = {feb},
  url    = {https://chungyc.org/files/publications/thesis.pdf}
}

@inproceedings{kim:sutc2008,
  author    = {Sungil Kim and Yoo Chul Chung and Yangwoo Ko and Dongman Lee},
  booktitle = {2008 IEEE International Conference on Sensor Networks, Ubiquitous, and Trustworthy Computing},
  title     = {A Reactive Local Positioning System for Ad Hoc Networks},
  year      = {2008},
  pages     = {44--51},
  abstract  = {Existing ad hoc location systems measure locations proactively by continuous measurements and communication among all nodes in an ad hoc network. However, in certain location-based applications only a few nodes need the location of a few other nodes, in which case the proactive approach results in an unnecessarily large overhead. We propose a scheme for a reactive ad hoc location system, which avoids the overhead of a proactive scheme by limiting multi-lateration and coordination of coordinate systems to nodes centered around the route between the source node requesting the location and the target node whose location is being requested. Simulations show that our scheme reduces overheads substantially compared to an existing proactive scheme.},
  keywords  = {reactive;ad-hoc;positioning;local coordinate system;mobile},
  doi       = {10.1109/SUTC.2008.22},
  url       = {https://doi.ieeecomputersociety.org/10.1109/SUTC.2008.22},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {jun}
}


@inproceedings{chung:percom2008,
  author    = {Yoo Chul Chung and Dongman Lee},
  booktitle = {2008 6th Annual IEEE International Conference on Pervasive Computing and Communications (PerCom &#x27;08)},
  title     = {Non-anchored Unified Naming for Ubiquitous Computing Environments},
  year      = {2008},
  pages     = {260--263},
  abstract  = {Users and developers require some way to identify by human readable names the many resources that comprise a ubiquitous computing environment. In addition, naming in such environments should work well despite ad~hoc situations, and it should also provide context-based naming. This paper describes the Non-anchored Unified Naming (NUN) system, which satisfies these requirements. It is based on relative naming among resources and provides the ability to name arbitrary types of resources. By having resources themselves take part in naming, resources are able to contribute their specialized knowledge into the name resolution process, making context-dependent mapping of names to resources possible.},
  keywords  = {relative naming;unified naming},
  doi       = {10.1109/PERCOM.2008.57},
  url       = {https://doi.ieeecomputersociety.org/10.1109/PERCOM.2008.57},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {mar}
}

@inproceedings{chung:kiise2007,
  author    = {Yoo Chul Chung and Dongman Lee},
  booktitle = {Proceedings of the 34th KIISE Fall Conference},
  editor    = {},
  title     = {Impersonation with the Echo Protocol (abstract)},
  year      = {2007},
  month     = {oct},
  publisher = {Korean Institute of Information Scientists and Engineers},
  location  = {Busan, Korea},
  pages     = {116--117},
  doi       = {10.48550/arXiv.cs/0506066}
}

@inproceedings{chung:seus2007,
  author    = {Chung, Yoo Chul and Ko, Yangwoo and Cha, Youngrock and Lee, Dongman},
  editor    = {Obermaisser, Roman and Nah, Yunmook and Puschner, Peter and Rammig, Franz J.},
  title     = {A Framework for Supporting the Configuration and Automatic Integration of Heterogeneous Location Sensors},
  booktitle = {Software Technologies for Embedded and Ubiquitous Systems},
  year      = {2007},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {368--377},
  abstract  = {We propose a framework that supports user-friendly configuration of a new location sensor system and its integration with a location manager. The proposed framework abstracts the diversity of heterogeneous sensor technologies using adapters that provide a common interface to the location manager. Configuration of a location sensor system requires information provided by the vendor of the location sensor system, so we propose a configuration protocol with which a newly deployed location sensor system can provide and obtain configuration options and parameters. An integration protocol is proposed as well so that a newly deployed sensing system can be integrated as part of an existing location manager. In order to verify the efficiency of the proposed framework, we measured configuration time with our framework and against manual configuration. Experimental results show that the proposed framework reduces configuration time significantly.},
  isbn      = {978-3-540-75664-4},
  doi       = {10.1007/978-3-540-75664-4_37}
}


@article{yang:tpds2007,
  author    = {Byung-Sun Yang and Junpyo Lee and SeungIl Lee and Seongbae Park and Yoo C. Chung and Suhyun Kim and Kemal Ebcio\u{g}lu and Erik Altman and Soo-Mook Moon},
  journal   = {IEEE Transactions on Parallel and Distributed Systems},
  title     = {Efficient Register Mapping and Allocation in {L}aTTe, an Open-Source Java Just-in-Time Compiler},
  year      = {2007},
  volume    = {18},
  number    = {1},
  issn      = {1558-2183},
  pages     = {57--69},
  abstract  = {Abstract—Java just-in-time (JIT) compilers improve the performance of a Java virtual machine (JVM) by translating Java bytecode into native machine code on demand. One important problem in Java JIT compilation is how to map stack entries and local variables to registers efficiently and quickly, since register-based computations are much faster than memory-based ones, while JIT compilation overhead is part of the whole running time. This paper introduces LaTTe, an open-source Java JIT compiler that performs fast generation of efficiently register-mapped RISC code. LaTTe first maps &quot;all” local variables and stack entries into pseudoregisters, followed by real register allocation which also coalesces copies corresponding to pushes and pops between local variables and stack entries aggressively. Our experimental results indicate that LaTTe&#x27;s sophisticated register mapping and allocation really pay off, achieving twice the performance of a naive JIT compiler that maps all local variables and stack entries to memory. It is also shown that LaTTe makes a reasonable trade-off between quality and speed of register mapping and allocation for the bytecode. We expect these results will also be beneficial to parallel and distributed Java computing 1) by enhancing single-thread Java performance and 2) by significantly reducing the number of memory accesses which the rest of the system must properly order to maintain coherence and keep threads synchronized.},
  keywords  = {java virtual machine;just-in-time compilation;register mapping;register allocation;copy coalescing.},
  doi       = {10.1109/TPDS.2007.10},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {jan}
}

@inproceedings{lee:seus2006,
  author    = {Kyungmin Lee and Dongman Lee and YangWoo Ko and Jaeik Lee and Yoo Chul Chung},
  booktitle = {The IEEE Workshop on Software Technologies for Future Embedded and Ubiquitous Systems, and International Workshop on Collaborative Computing, Integration, and Assurance},
  title     = {An Objectified Naming System for Providing Context Transparency to Context-Aware Applications},
  year      = {2006},
  pages     = {95--100},
  abstract  = {This paper describes the design and implementation of the Objectified Naming System (ONS) that provides a context-aware application with context transparent identification and rebinding of services, despite changes in its context or administrative domain. ONS treats a name as a first-class object, called a name object, which hides the name resolution and service rebinding procedures required when the context or administrative domain changes. ONS provides a context-based name structure, a context-aware name resolution mechanism, and an automated service rebinding mechanism. With ONS, applications can use name objects to refer to services in a context transparent way, regardless of context or administrative domain. The prototype implementation and experimental results indicate that ONS can streamline the development process of context-aware applications with reasonable runtime overhead.},
  doi       = {10.1109/SEUS-WCCIA.2006.14},
  url       = {https://doi.ieeecomputersociety.org/10.1109/SEUS-WCCIA.2006.14},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {apr}
}

@article{choi:computer2005,
  author   = {Choi, Hyung-Kyu and Chung, Yoo C. and Moon, Soo-Mook},
  title    = {{J}ava Memory Allocation with Lazy Worst Fit for Small Objects},
  journal  = {The Computer Journal},
  volume   = {48},
  number   = {4},
  pages    = {437--442},
  year     = {2005},
  month    = {jan},
  abstract = {Memory allocation is an important part of modern programming languages, including garbage-collected languages such as Java. We propose a fast memory allocation scheme for Java using lazy worst fit (LWF), where pointer increment is used as the primary allocation method and worst fit is used as a backup. We evaluated LWF on a working Java virtual machine with non-moving garbage collection, and the results show that LWF is practically useful since the overhead of fit allocation and the amount of fragmentation are low.},
  issn     = {0010-4620},
  doi      = {10.1093/comjnl/bxh101},
  url      = {https://doi.org/10.1093/comjnl/bxh101}
}

@article{chung:spe2005,
  author   = {Chung, Yoo C. and Moon, Soo-Mook and Ebcio\u{g}lu, Kemal and Sahlin, Dan},
  title    = {Selective sweeping},
  journal  = {Software: Practice and Experience},
  volume   = {35},
  number   = {1},
  pages    = {15--26},
  keywords = {garbage collection, mark and sweep, selective sweeping},
  doi      = {10.1002/spe.624},
  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.624},
  abstract = {Traditional mark and sweep garbage collectors use time proportional to the heap size when sweeping memory, since all objects in the heap, dead or alive, must be traversed. Here we introduce a sweeping algorithm which traverses only the live objects. Since this sweeping algorithm is slower when the heap occupancy is high, we also discuss how to avoid this slowdown by using an adaptive algorithm.},
  year     = {2005}
}

@mastersthesis{chungyc:thesis2001,
  author = {Yoo Chul Chung},
  school = {Seoul National University},
  title  = {Reducing Sweep Time for Sparse Heaps},
  year   = {2001}
}

@inproceedings{chung:ismm2000,
  author    = {Chung, Yoo and Moon, Soo-Mook},
  title     = {Memory Allocation with Lazy Fits},
  year      = {2000},
  isbn      = {1581132638},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/362422.362457},
  doi       = {10.1145/362422.362457},
  abstract  = {Dynamic memory allocation is an important part of modern programming languages. It is important that it be done fast without wasting too much memory. Memory allocation using lazy fits is introduced, where pointer increments, which is very fast, is used as the primary allocation method and where conventional fits such as best fit or first fit are used as backup. Some experimental results showing how lazy fits might perform are shown, and shows that the approach has the potential to be useful in actual systems.},
  booktitle = {Proceedings of the 2nd International Symposium on Memory Management},
  pages     = {65--70},
  numpages  = {6},
  location  = {Minneapolis, Minnesota, USA},
  series    = {ISMM '00}
}

@article{lee:sigarch2000,
  author     = {Lee, Junpyo and Yang, Byung-Sun and Kim, Suhyun and Ebcio\u{g}lu, Kemal and Altman, Erik and Lee, Seungil and Chung, Yoo C. and Lee, Heungbok and Lee, Je Hyung and Moon, Soo-Mook},
  title      = {Reducing Virtual Call Overheads in a {J}ava {VM} Just-in-Time Compiler},
  year       = {2000},
  issue_date = {March 2000},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {1},
  issn       = {0163-5964},
  url        = {https://doi.org/10.1145/346023.346037},
  doi        = {10.1145/346023.346037},
  abstract   = {Java, an object-oriented language, uses virtual methods to support the extension and reuse of classes. Unfortunately, virtual method calls affect performance and thus require an efficient implementation, especially when just-in-time (JIT) compilation is done. Inline caches and type feedback are solutions used by compilers for dynamically-typed object-oriented languages such as SELF [1, 2, 3], where virtual call overheads are much more critical to performance than in Java. With an inline cache, a virtual call that would otherwise have been translated into an indirect jump with two loads is translated into a simpler direct jump with a single compare. With type feedback combined with adaptive compilation, virtual methods can be inlined using checking code which verifies if the target method is equal to the inlined one.This paper evaluates the performance impact of these techniques in an actual Java virtual machine, which is our new open source Java VM JIT compiler called LaTTe [4]. We also discuss the engineering issues in implementing these techniques.Our experimental results with the SPECjvm98 benchhmarks indicate that while monomoprhic inline caches and polymorphic inline caches achieve a speedup as much as a geometric mean of 3\% and 9\% respectively, type feedback cannot improve further over polymorphic inline caches and even degrades the performance for some programs.},
  journal    = {SIGARCH Computure Architecture News},
  month      = {mar},
  pages      = {21--33},
  numpages   = {13},
  keywords   = {adaptive compilation, inline cache, virtual method call, Java JIT compilation, type feedback}
}

@article{chung:sigplan2000,
  author     = {Chung, Yoo C. and Voss, Michael J. and Cytron, Ron},
  title      = {Summary of the {D}ynamo '00 Panel Discussion (Panel Session)},
  year       = {2000},
  issue_date = {July 2000},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {35},
  number     = {7},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/351403.351426},
  doi        = {10.1145/351403.351426},
  journal    = {ACM SIGPLAN Notices},
  month      = {jan},
  pages      = {79--81},
  numpages   = {3}
}

@inproceedings{chungyc:popl2000,
  author    = {Chung, Yoo C. and Moon, Soo-Mook and Ebcio\u{g}lu, Kemal and Sahlin, Dan},
  title     = {Reducing Sweep Time for a Nearly Empty Heap},
  year      = {2000},
  isbn      = {1581131259},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/325694.325744},
  doi       = {10.1145/325694.325744},
  abstract  = {Mark and sweep garbage collectors are known for using time proportional to the heap size when sweeping memory, since all objects in the heap, regardless of whether they are live or not, must be visited in order to reclaim the memory occupied by dead objects. This paper introduces a sweeping method which traverses only the live objects, so that sweeping can be done in time dependent only on the number of live objects in the heap.This allows each collection to use time independent of the size of the heap, which can result in a large reduction of overall garbage collection time in empty heaps. Unfortunately, the algorithm used may slow down overall garbage collection if the heap is not so empty. So a way to select the sweeping algorithm depending on the heap occupancy is introduced, which can avoid any significant slowdown.},
  booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {378--389},
  numpages  = {12},
  location  = {Boston, MA, USA},
  series    = {POPL '00}
}

@inproceedings{yang:pact1999,
  author    = {Byung-Sun Yang and Soo-Mook Moon and Seongbae Park and Junpyo Lee and SeungIl Lee and Jinpyo Park and Yoo C. Chung and Suhyun Kim and Kemal Ebcio\u{g}lu and Erik Altman},
  booktitle = {Proceedings of the 22nd International Conference on Parallel Architectures and Compilation Techniques},
  title     = {LaTTe: A {J}ava {VM} Just-in-Time Compiler with Fast and Efficient Register Allocation},
  year      = {1999},
  issn      = {1089-795X},
  pages     = {128--138},
  abstract  = {For network computing on desktop machines, fast execution of Java bytecode programs is essential because these machines are expected to run substantial application programs written in Java. Higher Java performance can be achieved by Just-in-Time (JIT) compilers which translate the stack-based bytecode into register-based machine code on demand. One crucial problem in Java JIT compilation is how to map and allocate stack entries and local variables into registers efficiently and quickly, so as to improve the Java performance.This paper introduces LaTTe, a Java JIT compiler that performs fast and efficient register mapping and allocation for RISC machines. LaTTe first translates the bytecode into pseudo RISC code with symbolic registers, which is then register allocated while coalescing those copies corresponding to pushes and pops between local variables and the stack. The LaTTe JVM also includes an enhanced object model, a lightweight monitor, a fast mark-and-sweep garbage collector, and an on-demand exception handling mechanism, all of which are closely coordinated with LaTTe&#x27;s JIT compilation.Our experimental results on the SPARC platform with SPECJVM98 benchmarks and 15 non-trivial Java programs indicate that the current LaTTe JVMs achieve performance better than or comparable to the latest SUN JIT compilers (JDK 1.1.6 and HotSpot). It is also shown that LaTTe makes a reasonable trade-off between quality and speed of register allocation (i.e., the translation overhead consistently takes 1-2 seconds for SPECJVM98 which runs 40-80 seconds on LaTTe).},
  keywords  = {java jit compilation;register allocation},
  doi       = {10.1109/PACT.1999.807503},
  url       = {https://doi.ieeecomputersociety.org/10.1109/PACT.1999.807503},
  publisher = {IEEE Computer Society},
  address   = {Los Alamitos, CA, USA},
  month     = {oct}
}

@manual{chungyc:tldp1998,
  author       = {Yoo Chung},
  title        = {{L}inux Sound Playing HOWTO},
  year         = {1998},
  month        = {aug},
  organization = {Linux Documentation Project},
  url          = {https://tldp.org/HOWTO/Sound-Playing-HOWTO.html},
  note         = {Written when playing sound and music on Linux was not a trivial thing.}
}
