-- |
-- Description: Numbered values.
-- Copyright: Copyright (C) 2025 Yoo Chung
-- License: All rights reserved
-- Maintainer: web@chungyc.org
--
-- Provides an infinite map of positive integers to values.
--
-- It can be used to define a single mapping from positive integers to particular values declaratively.
-- Contrast this to building multiple finite maps of positive integers to particular values,
-- where each value is added one by one or in a finite batch via a list to a previous map,
-- but semantic-wise no single finite map will be able to hold all values.
--
-- For example, it could be used to create numbered Fibonacci numbers,
-- where a single map of numbered values can be used to return the \(n\)th Fibonacci number.
--
-- >>> let fib = build (\x -> case x of 1 -> 1; 2 -> 1; n -> find fib (n-1) + find fib (n-2))
-- >>> find fib 3
-- 2
-- >>> find fib 10
-- 55
-- >>> find fib 100
-- 354224848179261915075
--
-- This is not so useful for computing particular values themselves,
-- in which case a straightfoward application of a function to a number should suffice,
-- but it may be useful when many numbered values are desired,
-- and each numbered value may need other numbered values to be computed.
--
-- == __How it works__
--
-- The map is basically a lopsided infinite binary tree which is self-similar.
-- There is a trunk where each number starts from the multiplcative factor \(2^k\)
-- for each level, i.e., 1, 2, 4, 8, 16, ...
-- From each point in the trunk, another tree branches off which looks exactly the same,
-- where the numbering for each value starts right after the number starting a point on the trunk.
--
-- Each sub-tree is infinite to keep the code simple,
-- but we never infinitely search through a particular branch
-- because we have an upper limit for how many numbered values
-- we will ever search for from a particular branch.
-- Values with higher numbering will always start the search from
-- a branch starting from lower on the trunk.
--
-- For a sub-tree which starts with the \(n\)th value and has a branching factor \(b\):
--
-- * The root of the sub-tree will contain the \(n\)th value.
--
-- * The branch will be used to search for the \((n+1)\)th to \((n+b-1)\)th values.
--
-- * The sub-tree down the trunk will start with the \((n+b)\)th value and have branching factor \(2b\).
--
-- Due to the branching factor increasing exponentially down a trunk,
-- searching for the \(n\)th value through portions of the tree that have
-- already been evaluated is in \(O(\log n)\) time.
module Data.Numbered (Numbered, build, find) where

-- | Numbered values.
--
-- Specifically, it is an infinite map from positive integers to values.
-- Finding a value for an integer \(n\) is an \(O(\log n)\) operation
-- for parts of the map that have already been built lazily.
-- Actually building parts of the map is equivalent to finding a value from the map,
-- barring what is done by the function mapping a number to a value.
--
-- For example,
--
-- >>> let xs = build (*3) :: Numbered Integer
-- >>> find xs 4
-- 12
-- >>> find xs 111
-- 333
data Numbered a = Numbered
  { -- | The specific value for a numbering.
    value :: a,
    -- | Branch of the tree which contains values for numberings right after
    -- the current numbering and right before what starts in the trunk.
    --
    -- The branch is a tree which with a brand new trunk.
    branch :: Numbered a,
    -- | Trunk of the tree, where each increase in the level
    -- increases the numbering exponentially.
    trunk :: Numbered a
  }

-- | Builds numbered values.
-- Values are generated by applying the given function to their numbering.
--
-- For example, with the function 'show', "1" will be the 1st string,
-- "2" will be the 2nd string, ad infinitum.
--
-- >>> let xs = build show :: Numbered String
-- >>> find xs 1
-- "1"
-- >>> find xs 2
-- "2"
-- >>> find xs 100
-- "100"
build ::
  (Integral c) =>
  -- | Maps numbering to value.
  (c -> a) ->
  -- | Numbered values.
  Numbered a
build f = build' f 1 1

-- | Actual implementation of 'build',
-- which includes tracking which number starts off a particular sub-tree,
-- and the current branching factor used while going down the trunk.
build' ::
  (Integral c) =>
  -- | Maps numbering to value.
  (c -> a) ->
  -- | First number in tree.
  c ->
  -- | Branching factor.
  c ->
  -- | Numbered values.
  Numbered a
build' f n b =
  Numbered
    { value = f n,
      branch = build' f (n + 1) 1,
      trunk = build' f (n + b) (2 * b)
    }

-- | Finds a particular numbered value.
--
-- For example, with the @n@th value being @show n@, we find the 10th value
-- and the 121st value in the following:
--
-- >>> let xs = build show :: Numbered String
-- >>> find xs 10
-- "10"
-- >>> find xs 121
-- "121"
find ::
  (Integral c) =>
  -- | Numbered values.
  Numbered a ->
  -- | Numbering to find from.
  c ->
  -- | Value with the numbering.
  a
find xs n = find' xs n 1

-- | Actual implementation for 'find',
-- which includes tracking how much through a tree a value should be searched for
-- and the current branching factor used to go down the trunk.
find' ::
  (Integral c) =>
  -- | Numbered values.
  Numbered a ->
  -- | Numbering to find from.
  c ->
  -- | Branching factor.
  c ->
  -- | Value
  a
find' (Numbered {value = value}) 1 _ = value
find' (Numbered {trunk = trunk, branch = branch}) m b
  | m <= b = find' branch (m - 1) 1
  | otherwise = find' trunk (m - b) (2 * b)
